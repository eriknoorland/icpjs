!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).icpjs=e()}(this,(function(){"use strict";const t=t=>"x"in t&&"y"in t;var e=(t,e)=>{const n=t.x-e.x,r=t.y-e.y;return Math.pow(n*n+r*r,.5)},n=(t,e)=>t.map((t=>({x:t.x+e.x,y:t.y+e.y}))),r=(t,e)=>{const{phi:n}=e,r=Math.sin(n),o=Math.cos(n);return t.map((t=>({x:o*t.x-r*t.y,y:r*t.x+o*t.y})))},o=(t,n)=>{const r=n.length;let o=1/0,i={x:1/0,y:1/0};for(let y=0;y<r;y+=1){const r=n[y],x=e(t,r);x<o&&(o=x,i=r)}return i},i=(t,e)=>({x:t.x-e.x,y:t.y-e.y}),y=({x:t,y:e})=>t*t+e*e,x=(t,{x1:e,y1:n,x2:r,y2:o})=>{const x=y(i(t,{x:r,y:o})),s=y(i({x:e,y:n},{x:r,y:o})),a=y(i(t,{x:e,y:n}));if(a+s<x)return{x:e,y:n};if(x+s<a)return{x:r,y:o};let l,f=n-o,h=r-e,c=e*o-r*n;if(0===h){if(0===f)return null;l=-f,f=-1,c/=l}else l=-h,f/=l,h=-1,c/=l;if(0!==h){let e;return e=0!==f?(t.x/f+t.y-c)/(f+1/f):t.x,{x:e,y:f*e+c}}return{x:c/-f,y:t.y}},s=(t,n)=>{const r=n.length;let o=1/0,i={x:1/0,y:1/0};for(let y=0;y<r;y+=1){const r=n[y],s=x(t,r);if(!s)continue;const a=e(t,s);a<o&&(o=a,i=s)}return i};return Object.freeze({run:(i,y,x={x:0,y:0,phi:0},a={})=>{if(!i.length)throw new Error("At least 1 reference point or line segment is required");const l=i[0],f=t(l),h="x1"in(c=l)&&"x2"in c&&"y1"in c&&"y2"in c;var c;if(!f&&!h)throw new Error("The reference should either be an array of points or line segments");if(!y.length)throw new Error("At least 1 data point is required");if(!t(y[0]))throw new Error("The data should be an array of points");const u=Object.assign({method:h?s:o,maxIterations:20,tolerance:.1},a),p=y.length,d={x:0,y:0,phi:0};let m=[...y],g=0;for(let t=0;t<u.maxIterations;t+=1){let t=0,o=0,y=0,s=0,a=0,l=0,f=0,h=0,c=0;for(let e=0;e<p;e+=1){const n=m[e],r=u.method(n,i);if(!r)continue;t+=1;const p={x:n.x-x.x,y:n.y-x.y},d={x:r.x-x.x,y:r.y-x.y};o+=p.x,y+=d.x,s+=p.y,a+=d.y,l+=p.x*d.x,f+=p.y*d.y,h+=p.x*d.y,c+=p.y*d.x}const b=l-o*y/t,w=f-s*a/t,M=h-o*a/t,j=c-s*y/t,T=o/t,E=s/t,I=y/t,O=a/t;if(e({x:T,y:E},{x:I,y:O})<u.tolerance)break;const q={x:0,y:0,phi:0};q.phi=Math.atan2(M-j,b+w);const v=Math.cos(q.phi),z=Math.sin(q.phi);q.x=I-(T*v-E*z),q.y=O-(T*z+E*v),m=n(m,q),m=r(m,q),d.x+=q.x,d.y+=q.y,d.phi+=q.phi,g+=1}return Object.freeze({transformation:d,dataPoints:m,numIterations:g})},utils:{applyTranslation:n,applyRotation:r}})}));
