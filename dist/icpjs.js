const t=t=>"x"in t&&"y"in t;var e=(t,e)=>{const n=t.x-e.x,r=t.y-e.y;return Math.pow(n*n+r*r,.5)},n=(t,e)=>t.map((t=>({x:t.x+e.x,y:t.y+e.y}))),r=(t,e)=>{const{phi:n}=e,r=Math.sin(n),o=Math.cos(n);return t.map((t=>({x:o*t.x-r*t.y,y:r*t.x+o*t.y})))},o=(t,n)=>{const r=n.length;let o=1/0,y={x:1/0,y:1/0};for(let x=0;x<r;x+=1){const r=n[x],i=e(t,r);i<o&&(o=i,y=r)}return y},y=(t,e)=>({x:t.x-e.x,y:t.y-e.y}),x=({x:t,y:e})=>t*t+e*e,i=(t,{x1:e,y1:n,x2:r,y2:o})=>{const i=x(y(t,{x:r,y:o})),a=x(y({x:e,y:n},{x:r,y:o})),s=x(y(t,{x:e,y:n}));if(s+a<i)return{x:e,y:n};if(i+a<s)return{x:r,y:o};let h,l=n-o,c=r-e,f=e*o-r*n;if(0===c){if(0===l)return null;h=-l,l=-1,f/=h}else h=-c,l/=h,c=-1,f/=h;if(0!==c){let e;return e=0!==l?(t.x/l+t.y-f)/(l+1/l):t.x,{x:e,y:l*e+f}}return{x:f/-l,y:t.y}},a=(t,n)=>{const r=n.length;let o=1/0,y={x:1/0,y:1/0};for(let x=0;x<r;x+=1){const r=n[x],a=i(t,r);if(!a)continue;const s=e(t,a);s<o&&(o=s,y=a)}return y},s=Object.freeze({run:(y,x,i={x:0,y:0,phi:0},s={})=>{if(!y.length)throw new Error("At least 1 reference point or line segment is required");const h=y[0],l=t(h),c="x1"in(f=h)&&"x2"in f&&"y1"in f&&"y2"in f;var f;if(!l&&!c)throw new Error("The reference should either be an array of points or line segments");if(!x.length)throw new Error("At least 1 data point is required");if(!t(x[0]))throw new Error("The data should be an array of points");const p=Object.assign({method:c?a:o,maxIterations:20,tolerance:.1},s),u=x.length,d={x:0,y:0,phi:0};let m=[...x],w=0;for(let t=0;t<p.maxIterations;t+=1){let t=0,o=0,x=0,a=0,s=0,h=0,l=0,c=0,f=0;for(let e=0;e<u;e+=1){const n=m[e],r=p.method(n,y);if(!r)continue;t+=1;const u={x:n.x-i.x,y:n.y-i.y},d={x:r.x-i.x,y:r.y-i.y};o+=u.x,x+=d.x,a+=u.y,s+=d.y,h+=u.x*d.x,l+=u.y*d.y,c+=u.x*d.y,f+=u.y*d.x}const g=h-o*x/t,b=l-a*s/t,M=c-o*s/t,E=f-a*x/t,j=o/t,I=a/t,O=x/t,T=s/t;if(e({x:j,y:I},{x:O,y:T})<p.tolerance)break;const q={x:0,y:0,phi:0};q.phi=Math.atan2(M-E,g+b);const v=Math.cos(q.phi),z=Math.sin(q.phi);q.x=O-(j*v-I*z),q.y=T-(j*z+I*v),m=n(m,q),m=r(m,q),d.x+=q.x,d.y+=q.y,d.phi+=q.phi,w+=1}return Object.freeze({transformation:d,dataPoints:m,numIterations:w})},utils:{applyTranslation:n,applyRotation:r}});export{s as default};
